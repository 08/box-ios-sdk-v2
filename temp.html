<style type="text/css">
a {
  color: #4183C4;
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}
h1 {
  border-bottom: 3px solid #ccc;
  padding-bottom: 10px;
}
body {
  font: 14px / 20px "Helvetica Neue", Helvetica, "Lucida Grande", Arial, Verdana, sans-serif;
}
pre, code {
  font-family: "Inconsolata", "Ubuntu Mono", Courier, monospace;
  background-color: #F0EEEA;
  padding: 2px;
}
.highlight pre {
  padding-left: 6px;
}
#wrapper {
  width: 900px;
  margin: 50px auto;
  border: 3px solid #ccc;
  padding: 0px 15px;
}
pre .hll {
  background-color: #ffffcc;
}
pre .c {
  color: #408080;
  font-style: italic;
}
pre .k {
  color: #5d2846;
  font-weight: bold;
}
pre .o {
  color: #666666;
}
pre .cm {
  color: #408080;
  font-style: italic;
}
pre .cp {
  color: #bc7a00;
}
pre .c1 {
  color: #408080;
  font-style: italic;
}
pre .cs {
  color: #408080;
  font-style: italic;
}
pre .gd {
  color: #a00000;
}
pre .ge {
  font-style: italic;
}
pre .gr {
  color: #ff0000;
}
pre .gh {
  color: #000080;
  font-weight: bold;
}
pre .gi {
  color: #00a000;
}
pre .go {
  color: #808080;
}
pre .gp {
  color: #000080;
  font-weight: bold;
}
pre .gs {
  font-weight: bold;
}
pre .gu {
  color: #800080;
  font-weight: bold;
}
pre .gt {
  color: #0040d0;
}
pre .kc {
  color: #5d2846;
  font-weight: bold;
}
pre .kd {
  color: #5d2846;
  font-weight: bold;
}
pre .kn {
  color: #5d2846;
  font-weight: bold;
}
pre .kp {
  color: #5d2846;
}
pre .kr {
  color: #5d2846;
  font-weight: bold;
}
pre .kt {
  color: #b00040;
}
pre .m {
  color: #666666;
}
pre .s {
  color: #4eb25a;
}
pre .na {
  color: #7d9029;
}
pre .nb {
  color: #5d2846;
}
pre .nc {
  color: #3333a0;
  font-weight: bold;
}
pre .no {
  color: #28732c;
}
pre .nd {
  color: #aa22ff;
}
pre .ni {
  color: #999999;
  font-weight: bold;
}
pre .ne {
  color: #d2413a;
  font-weight: bold;
}
pre .nf {
  color: #3333a0;
}
pre .nl {
  color: #a0a000;
}
pre .nn {
  color: #3333a0;
  font-weight: bold;
}
pre .nt {
  color: #5d2846;
  font-weight: bold;
}
pre .nv {
  color: #353c92;
}
pre .ow {
  color: #aa22ff;
  font-weight: bold;
}
pre .w {
  color: #bbbbbb;
}
pre .mf {
  color: #666666;
}
pre .mh {
  color: #666666;
}
pre .mi {
  color: #666666;
}
pre .mo {
  color: #666666;
}
pre .sb {
  color: #4eb25a;
}
pre .sc {
  color: #4eb25a;
}
pre .sd {
  color: #4eb25a;
  font-style: italic;
}
pre .s2 {
  color: #4eb25a;
}
pre .se {
  color: #bb6622;
  font-weight: bold;
}
pre .sh {
  color: #4eb25a;
}
pre .si {
  color: #bb6688;
  font-weight: bold;
}
pre .sx {
  color: #5d2846;
}
pre .sr {
  color: #bb6688;
}
pre .s1 {
  color: #4eb25a;
}
pre .ss {
  color: #353c92;
}
pre .bp {
  color: #5d2846;
}
pre .vc {
  color: #353c92;
}
pre .vg {
  color: #353c92;
}
pre .vi {
  color: #353c92;
}
pre .il {
  color: #666666;
}
</style>
<div id="wrapper">
<h1>BoxSDK: Box API V2 iOS SDK</h1>

<p>This SDK provides access to the <a href="https://developers.box.com/docs/">Box V2 API</a>.
It currently supports file and folder operations.</p>

<h2>Add to your project</h2>

<p>The easiest way to add the Box SDK to your project is as a dependent XCode project.</p>

<ol>
<li>Clone this repository into your project&#39;s directory. You can use git submodules
if you want.</li>
<li>Open your project in XCode.</li>
<li><p>Drag BoxSDK.xcodeproj into the root of your project explorer.<br /><img src="http://box.github.io/box-ios-sdk-private/readme-images/dependent-project.png" alt="Dependent project"></p></li>
<li><p>Add the BoxSDK project as a target dependency.<br /><img src="http://box.github.io/box-ios-sdk-private/readme-images/target-dependency.png" alt="Target dependency"></p></li>
<li><p>Link with libBoxSDK.a<br /><img src="http://box.github.io/box-ios-sdk-private/readme-images/link-with-binary.png" alt="Link with binary"></p></li>
<li><p>Add the <code>-ObjC</code> linker flag. This is needed to load categories defined in the SDK.<br /><img src="http://box.github.io/box-ios-sdk-private/readme-images/linker-flag.png" alt="Add linker flag"></p></li>
</ol>

<h2>Quickstart</h2>

<h3>Configure</h3>

<p>Set your client ID and client secret on the SDK client:</p>

<pre><code class="objc">[BoxSDK sharedSDK].OAuth2Session.clientID = @&quot;YOUR_CLIENT_ID&quot;;
[BoxSDK sharedSDK].OAuth2Session.clientSecret = @&quot;YOUR_CLIENT_SECRET&quot;;
</code></pre>

<p>The SDK requires your app to register a custom URL scheme in order to receive
an OAuth2 authorization code. In your <code>Info.plist</code>, register the following URL
scheme:</p>

<pre><code>boxsdk-YOUR_CLIENT_ID
</code></pre>

<h3>Authenticate</h3>

<p>To authenticate your app with Box, you need to use OAuth2. The authorization flow
happens in a <code>UIWebView</code>. To get started, you can present the sample web view the
SDK provides:</p>

<pre><code class="objc">UIViewController *authorizationController = [[BoxAuthorizationViewController alloc] initWithOAuth2Session:[BoxSDK sharedSDK].OAuth2Session];
[self presentViewController:authorizationController animated:YES completion:nil];
</code></pre>

<p>On successful authentication, your app will receive an &quot;open in&quot; request using
the custom URL scheme you registered earlier. In your app delegate:</p>

<pre><code class="objc">- (BOOL)application:(UIApplication *)application
            openURL:(NSURL *)url
  sourceApplication:(NSString*)sourceApplication
         annotation:(id)annotation
{
    [[BoxSDK sharedSDK].OAuth2Session performAuthorizationCodeGrantWithReceivedURL:url];
    return YES;
}
</code></pre>

<p>You can listen to notifications on <code>[BoxSDK sharedSDK].OAuth2Session</code> to be notified
when a user becomes successfully authenticated.</p>

<h3>Making API calls</h3>

<p>All SDK API calls are asynchronous. They are scheduled by the SDK on an <code>NSOperationQueue</code>.
To be notified of API responses and errors, pass blocks to the SDK API call methods. These
blocks are triggered once the API response has been received by the SDK.</p>

<p><strong>Note</strong>: callbacks are not triggered on the main thread. Wrap updates to your app&#39;s
UI in a <code>dispatch_sync</code> block on the main thread.</p>

<h4>Get a folder&#39;s children</h4>

<pre><code class="objc">BoxCollectionBlock success = ^(BoxCollection *collection)
{
  // grab items from the collection, use the collection as a data source
  // for a table view, etc.
};

BoxAPIJSONFailureBlock failure = ^(NSURLRequest *request, NSHTTPURLResponse *response, NSError *error, NSDictionary *JSONDictionary)
{
  // handle errors
};

[[BoxSDK sharedSDK].foldersManager folderItemsWithID:folderID requestBuilder:nil success:success failure:failure];
</code></pre>

<h4>Get a file&#39;s information</h4>

<pre><code class="objc">BoxFileBlock success = ^(BoxFile *file)
{
  // manipulate the BoxFile.
};

BoxAPIJSONFailureBlock failure = ^(NSURLRequest *request, NSHTTPURLResponse *response, NSError *error, NSDictionary *JSONDictionary)
{
  // handle errors
};

[[BoxSDK sharedSDK].filesManager fileInfoWithID:folderID requestBuilder:nil success:success failure:failure];
</code></pre>

<h4>Edit an item&#39;s information</h4>

<p>To send data via the API, use a request builder. If we wish to move a file and change its
name:</p>

<pre><code class="objc">BoxFileBlock success = ^(BoxFile *file)
{
  // manipulate the BoxFile.
};

BoxAPIJSONFailureBlock failure = ^(NSURLRequest *request, NSHTTPURLResponse *response, NSError *error, NSDictionary *JSONDictionary)
{
  // handle errors
};

BoxFilesRequestBuilder *builder = [BoxFilesRequestBuilder alloc] init];
builder.name = @&quot;My awesome file.txt&quot;
builder.parentID = BoxAPIFolderIDRoot;

[[BoxSDK sharedSDK].filesManager editFileWithID:folderID requestBuilder:builder success:success failure:failure];
</code></pre>

<h4>Upload a new file</h4>

<pre><code class="objc">BoxFileBlock fileBlock = ^(BoxFile *file)
{
  // manipulate resulting BoxFile
};

BoxAPIJSONFailureBlock failureBlock = ^(NSURLRequest *request, NSHTTPURLResponse *response, NSError *error, NSDictionary *JSONDictionary)
{
  // handle failed upload
};

BoxAPIMultipartProgressBlock progressBlock = ^(unsigned long long totalBytes, unsigned long long bytesSent)
{
  // indicate progress of upload
};

BoxFilesRequestBuilder *builder = [[BoxFilesRequestBuilder alloc] init];
builder.name = @&quot;Logo_Box_Blue_Whitebg_480x480.jpg&quot;;
builder.parentID = folderID;

NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;Logo_Box_Blue_Whitebg_480x480.jpg&quot; ofType:nil];
NSInputStream *inputStream = [NSInputStream inputStreamWithFileAtPath:path];
NSDictionary *fileAttributes = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil];
long long contentLength = [[fileAttributes objectForKey:NSFileSize] longLongValue];


NSData *data = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;Logo_Box_Blue_Whitebg_480x480&quot; ofType:@&quot;jpg&quot;]];

BoxAPIMultipartToJSONOperation *operation = [[BoxSDK sharedSDK].filesManager uploadFileWithInputStream:inputStream contentLength:contentLength MIMEType:nil requestBuilder:builder success:fileBlock failure:failureBlock progress:progressBlock];
</code></pre>

<h4>Download a file</h4>

<pre><code class="objc">NSOutputStream *outputStream = [NSOutputStream outputStreamToFileAtPath:path append:NO];

BoxDownloadSuccessBlock successBlock = ^(NSString *downloadedFileID, long long expectedContentLength)
{
  // handle download, preview download, etc.
};

BoxDownloadFailureBlock failureBlock = ^(NSURLRequest *request, NSHTTPURLResponse *response, NSError *error)
{
  // handle download failure
};

BoxAPIDataProgressBlock progressBlock = ^(long long expectedTotalBytes, unsigned long long bytesReceived)
{
  // display progress
};

[[BoxSDK sharedSDK].filesManager downloadFileWithID:fileID outputStream:outputStream requestBuilder:nil success:successBlock failure:failureBlock progress:progressBlock];
</code></pre>

<h2>Tests</h2>

<p>This SDK contains unit tests that are runnable with <code>./bin/test.sh</code>.</p>

<p>Pull requests will not be accepted unless they include test coverage.</p>

<h2>Documentation</h2>

<p>Documentation for this SDK is generated using <a href="http://gentlebytes.com/appledoc/">appledoc</a>.
And can be generated by running <code>./bin/generate-documentation.sh</code>.</p>

<p>Documentation is hosted on this repo&#39;s github page.</p>

<p>Pull requests will not be accepted unless they include documentation.</p>

<h2>Known issues</h2>

<ul>
<li>There is no support for manipulating files in the trash.</li>
<li>Only the files and folders endpoints are supported.</li>
</ul>
</div>
</div>
